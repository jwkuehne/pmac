;----------------------------------------------------------------------------------
;Motion control program: DEC track a satellite using Lagrange interpolated path.
;Application:   2.1M Telescope
;Author:        John Kuehne
;January 30, 2020
;
;----------------------------------------------------------------------------------
; Overlap some RAE definitions.

#include "defines.txt"

#define LONG_SECONDS P500; Sent by Track82 to synchronize clocks.
#define DELTA_TIME   P501; Interpolation time interval.
#define START_TIME_X P502; Track82 seconds start time for buffer X
#define START_TIME_Y P503; and for buffer Y.
#define BUFFER       P504; -1 is use ra_track_rate, 0 is buffer X, 1 is buffer Y.
#define DEC_BOLUS    P529; For track rate corrections computed in GUIDE82.
#define SYNC_T       P530; Estimate of transmission time from TRACK82
#define DX3          P519; Declination cofficients used in DEC ephemeris motion control.
#define DX2          P520
#define DX1          P521
#define DX0          P522
#define DY3          P523
#define DY2          P524
#define DY1          P525
#define DY0          P526
#define DBUFFER_INUSE P529; Protect against race conditions
#define DEC_INTERP   P605
#define DEC_INTERP1  P606
#define DEC_INTERP2  P607
#define DLAG1        P608
#define DLAG2        P609
#define DLAG3        P610
#define TIME_D       P631
#define DEC_WORM     P650
#define DEC_SYNC     P651
#define DEC_INC      P652
#define DEC_EXTRA    P653
#define DEC_GO_ABS   P654
#define D_MAX        P655; Maximum track rate in arcsec/sec*SUPER_D
  
#define SUPER_D      0.2

#define sysTime ((M561/32000) + LONG_SECONDS + SYNC_T);

close
delete gather

&2
#2->y
open prog 3 clear

i263=500 i267=7000 i211=13440; Stable position loop.
linear inc
TM(SUPER_D * 1000)
TA(SUPER_D * 100)
I216 = 109.375*150/1000; 109.375cnts/arcsec * 150arcsec/sec * (1sec/1000msec); SEARCH speed.
I217 = I216/SUPER_D
D_MAX = 150*SUPER_D; 150 arcsec/sec is SEARCH rate, will result in DEC preload turning off.

DBUFFER_INUSE = BUFFER;

TIME_D = sysTime; Set base time. TRACK82 has already set LONG_SECONDS and optional SYNC_T
;First get the current calculated position.
if (DBUFFER_INUSE = 0); buffers alternate between X and Y to prevent race condition when sent from TRACK82
   DLAG1 = 1 + ((TIME_D - START_TIME_X)/DELTA_TIME)
   DLAG2 = DLAG1*DLAG1; squared
   DLAG3 = DLAG2*DLAG1; cubed
   DEC_INTERP1 = 3600*(DX3*DLAG3 + DX2*DLAG2 + DX1*DLAG1 + DX0); Actual DEC in arcseconds for buffer X.
endif
if (DBUFFER_INUSE = 1)
   DLAG1 = 1 + ((TIME_D - START_TIME_Y)/DELTA_TIME)
   DLAG2 = DLAG1*DLAG1; squared
   DLAG3 = DLAG2*DLAG1; cubed
   DEC_INTERP1 = 3600*(DY3*DLAG3 + DY2*DLAG2 + DY1*DLAG1 + DY0); Actual DEC in arcseconds for buffer Y.
endif

DEC_SYNC = 0
while (1=1)
   DBUFFER_INUSE = BUFFER
   if (DBUFFER_INUSE > -1)
      if (DLAG1 < 0.5 or DLAG1 > 2.5); Lost contact with TRACK82's active ephemeris calculation.
         dec_track_on = 0
         cmd "&2A#2k"
      endif
   endif
   if (dec_step = 0)
      DEC_EXTRA = 0
   else
      DEC_GO_ABS = abs(dec_step); TRACK82 sends counts, not arcseconds.
      if (DEC_GO_ABS/109.375 > (60*SUPER_D/5))
         DEC_EXTRA = DEC_GO_ABS/dec_step*60*SUPER_D/5; dole out 60*SUPER_D/5 arcsecond steps, e.g. 12 arcsec/sec.
         dec_step = dec_step - DEC_EXTRA*109.375
      else
         DEC_EXTRA  = dec_step/109.375;
         dec_step = 0; clear guide register
      endif
   endif

   ; Get advanced position in SUPER_T seconds.
   TIME_D = TIME_D + SUPER_D; This depends on TM staying at SUPER_D and no PMAC extentions for motor limits.

   if (DBUFFER_INUSE = 0); buffers alternate between X and Y to prevent race condition when sent from TRACK82
      DLAG1 = 1 + ((TIME_D - START_TIME_X)/DELTA_TIME)
      DLAG2 = DLAG1*DLAG1; squared
      DLAG3 = DLAG2*DLAG1; cubed
      DEC_INTERP2 = 3600*(DX3*DLAG3 + DX2*DLAG2 + DX1*DLAG1 + DX0); Actual DEC for buffer X.
   endif
   if (DBUFFER_INUSE = 1)
      DLAG1 = 1 + ((TIME_D - START_TIME_Y)/DELTA_TIME)
      DLAG2 = DLAG1*DLAG1; squared
      DLAG3 = DLAG2*DLAG1; cubed
      DEC_INTERP2 = 3600*(DY3*DLAG3 + DY2*DLAG2 + DY1*DLAG1 + DY0); Actual DEC for buffer Y.
   endif

   ; Get incremental distance for this TM, limiting acceleration to prevent PMAC extending TM, avoid hard stops, protect DC bus.
   if (DBUFFER_INUSE = -1); No ephemeris. Use dec_track_rate.
      DEC_WORM = dec_track_rate/0.109375*SUPER_D; Desired distance to go in TM. dec_track_rate is sent from TRACK82 as counts/msec.
      DEC_INC  = DEC_WORM - DEC_SYNC;   Acceleration computed from previous DEC_WORM.
      if (abs(DEC_INC) > 60*SUPER_D);   Limit acceleration this SUPER_D cycle.
         DEC_WORM = DEC_SYNC + 60*SUPER_D*DEC_INC/abs(DEC_INC); Allow increase/decrease acceleration.
      endif
      DEC_SYNC = DEC_WORM; Save for next acceleration 
   else
      DEC_WORM = DEC_INTERP2 - DEC_INTERP1; Desired distance to go in TM.
      DEC_INC  = DEC_WORM - DEC_SYNC;     Acceleration computed from previous DEC_WORM.
      if (abs(DEC_INC) > 60*SUPER_D);     Limit acceleration this SUPER_D cycle. May trigger subversion restart.
         DEC_WORM = DEC_SYNC + 60*SUPER_D*DEC_INC/abs(DEC_INC); Allow increase/decrease of acceleration.
      endif
      DEC_SYNC = DEC_WORM; Save for next accleration 
      dec_track_rate = (DEC_INTERP2 - DEC_INTERP1)/SUPER_D*0.109375; TRACK82 rates are in cnts/msec
      DEC_INTERP1 = DEC_INTERP2 
   endif

   if (abs(DEC_WORM) > D_MAX); Kill both DEC and RA tracking for exceeding safety limits.
      dec_track_on = 0; Tell DEC PLC to stop tracking,
      cmd "&2A#2k"; and kill this program immediately.
   endif
   
   Y(109.375*(DEC_WORM + DEC_EXTRA)); Currently 109.375 counts per arcsecond. See defines for worm calculation.
   DEC_EXTRA = 0
   
endwhile
